import 'package:path/path.dart' as path;
import '../models/coverage_data.dart';
import '../models/source_file.dart';
import '../models/line_coverage.dart';
import '../utils/coverage_calculator.dart';
import '../utils/file_utils.dart';
import 'css_generator.dart';

/// Generator for HTML coverage reports from coverage data.
class HtmlGenerator {
  /// Configuration options for HTML generation
  final HtmlGeneratorOptions options;

  /// Creates a new HTML generator with the specified options
  const HtmlGenerator({required this.options});

  /// Generates HTML coverage report from coverage data
  Future<void> generateReport(CoverageData coverageData) async {
    // Ensure output directory exists
    await FileUtils.ensureDirectoryExists(options.outputDirectory);

    // Generate index.html
    final indexHtml = generateIndexHtml(coverageData);
    final indexPath = path.join(options.outputDirectory, 'index.html');
    await FileUtils.writeStringToFile(indexPath, indexHtml);

    // Generate individual source file HTML pages
    for (final sourceFile in coverageData.sourceFiles) {
      final sourceHtml = generateSourceFileHtml(sourceFile, coverageData);
      final sourceFileName = _getSourceFileHtmlName(sourceFile.path);
      final sourcePath = path.join(options.outputDirectory, sourceFileName);

      // Ensure subdirectories exist for nested files
      await FileUtils.ensureDirectoryExists(path.dirname(sourcePath));
      await FileUtils.writeStringToFile(sourcePath, sourceHtml);
    }
  }

  /// Generates the main index HTML file
  String generateIndexHtml(CoverageData coverageData) {
    final timestamp = _formatTimestamp(coverageData.timestamp);
    final sortedFiles = _sortSourceFiles(coverageData.sourceFiles);

    return '''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${_escapeHtml(options.title)}</title>
    ${CssGenerator.generateInlineCss()}
</head>
<body>
    <div class="header">
        <h1>${_escapeHtml(options.title)}</h1>
        <p>Generated on: $timestamp</p>
    </div>
    
    <div class="summary">
        <h2>Summary</h2>
        ${_generateSummaryTable(coverageData.summary)}
    </div>
    
    <div class="files">
        <h2>Files</h2>
        ${_generateFileListTable(sortedFiles)}
    </div>
    
    <div class="footer">
        Generated by genhtml
    </div>
</body>
</html>''';
  }

  /// Generates HTML for a specific source file
  String generateSourceFileHtml(
    SourceFile sourceFile,
    CoverageData coverageData,
  ) {
    final timestamp = _formatTimestamp(coverageData.timestamp);
    final breadcrumb = _generateBreadcrumb(sourceFile.path);
    final sourceCode = _generateSourceCodeDisplay(sourceFile);

    return '''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${_escapeHtml(sourceFile.path)} - ${_escapeHtml(options.title)}</title>
    ${CssGenerator.generateInlineCss()}
</head>
<body>
    <div class="header">
        <h1>${_escapeHtml(options.title)}</h1>
        <p>Generated on: $timestamp</p>
    </div>
    
    $breadcrumb
    
    <div class="summary">
        <h2>File: ${_escapeHtml(sourceFile.path)}</h2>
        ${_generateFileSummaryTable(sourceFile)}
    </div>
    
    <div class="source-code">
        $sourceCode
    </div>
    
    <div class="footer">
        Generated by genhtml
    </div>
</body>
</html>''';
  }

  /// Generates the summary table for overall coverage
  String _generateSummaryTable(dynamic summary) {
    return '''<table class="coverage-table">
            <tr>
                <th>Metric</th>
                <th>Coverage</th>
                <th>Functions</th>
                <th>Lines</th>
                ${options.showBranches ? '<th>Branches</th>' : ''}
            </tr>
            <tr>
                <td>Total</td>
                <td class="${CssGenerator.getCoverageClass(summary.overallCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(summary.overallCoveragePercentage)}</td>
                <td>${summary.functionsCoverageString}</td>
                <td>${summary.linesCoverageString}</td>
                ${options.showBranches ? '<td>${summary.branchesCoverageString}</td>' : ''}
            </tr>
        </table>''';
  }

  /// Generates the file list table
  String _generateFileListTable(List<SourceFile> sourceFiles) {
    final buffer = StringBuffer();

    buffer.writeln('<table class="coverage-table">');
    buffer.writeln('    <tr>');
    buffer.writeln('        <th>File</th>');
    buffer.writeln('        <th>Line Coverage</th>');
    if (options.showFunctions) {
      buffer.writeln('        <th>Function Coverage</th>');
    }
    if (options.showBranches) {
      buffer.writeln('        <th>Branch Coverage</th>');
    }
    buffer.writeln('        <th>Lines</th>');
    if (options.showFunctions) {
      buffer.writeln('        <th>Functions</th>');
    }
    if (options.showBranches) {
      buffer.writeln('        <th>Branches</th>');
    }
    buffer.writeln('    </tr>');

    for (final sourceFile in sourceFiles) {
      buffer.writeln('    <tr>');
      buffer.writeln(
        '        <td><a href="${_getSourceFileHtmlName(sourceFile.path)}" class="file-link">${_escapeHtml(sourceFile.path)}</a></td>',
      );
      buffer.writeln(
        '        <td class="${CssGenerator.getCoverageClass(sourceFile.lineCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.lineCoveragePercentage)}</td>',
      );

      if (options.showFunctions) {
        buffer.writeln(
          '        <td class="${CssGenerator.getCoverageClass(sourceFile.functionCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.functionCoveragePercentage)}</td>',
        );
      }

      if (options.showBranches) {
        buffer.writeln(
          '        <td class="${CssGenerator.getCoverageClass(sourceFile.branchCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.branchCoveragePercentage)}</td>',
        );
      }

      buffer.writeln(
        '        <td>${sourceFile.hitLines}/${sourceFile.totalLines}</td>',
      );

      if (options.showFunctions) {
        buffer.writeln(
          '        <td>${sourceFile.hitFunctions}/${sourceFile.totalFunctions}</td>',
        );
      }

      if (options.showBranches) {
        buffer.writeln(
          '        <td>${sourceFile.hitBranches}/${sourceFile.totalBranches}</td>',
        );
      }

      buffer.writeln('    </tr>');
    }

    buffer.writeln('</table>');
    return buffer.toString();
  }

  /// Generates the summary table for a specific file
  String _generateFileSummaryTable(SourceFile sourceFile) {
    return '''<table class="coverage-table">
            <tr>
                <th>Metric</th>
                <th>Coverage</th>
                <th>Total</th>
                <th>Covered</th>
            </tr>
            <tr>
                <td>Lines</td>
                <td class="${CssGenerator.getCoverageClass(sourceFile.lineCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.lineCoveragePercentage)}</td>
                <td>${sourceFile.totalLines}</td>
                <td>${sourceFile.hitLines}</td>
            </tr>
            ${options.showFunctions ? '''<tr>
                <td>Functions</td>
                <td class="${CssGenerator.getCoverageClass(sourceFile.functionCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.functionCoveragePercentage)}</td>
                <td>${sourceFile.totalFunctions}</td>
                <td>${sourceFile.hitFunctions}</td>
            </tr>''' : ''}
            ${options.showBranches ? '''<tr>
                <td>Branches</td>
                <td class="${CssGenerator.getCoverageClass(sourceFile.branchCoveragePercentage)}">${CoverageCalculator.formatCoveragePercentage(sourceFile.branchCoveragePercentage)}</td>
                <td>${sourceFile.totalBranches}</td>
                <td>${sourceFile.hitBranches}</td>
            </tr>''' : ''}
        </table>''';
  }

  /// Generates breadcrumb navigation
  String _generateBreadcrumb(String filePath) {
    final parts = filePath.split('/');
    final buffer = StringBuffer();

    buffer.writeln('<div class="breadcrumb">');
    buffer.write('<a href="index.html">Coverage Report</a>');

    for (int i = 0; i < parts.length; i++) {
      buffer.write('<span class="separator">Â»</span>');

      if (i == parts.length - 1) {
        // Last part (filename) - not a link
        buffer.write('<span>${_escapeHtml(parts[i])}</span>');
      } else {
        // Directory part - could be a link to directory index if we implement it
        buffer.write('<span>${_escapeHtml(parts[i])}</span>');
      }
    }

    buffer.writeln('</div>');
    return buffer.toString();
  }

  /// Generates source code display with line-by-line coverage
  String _generateSourceCodeDisplay(SourceFile sourceFile) {
    final buffer = StringBuffer();

    // Create a map of line numbers to coverage data for quick lookup
    final lineCoverageMap = <int, LineCoverage>{};
    for (final line in sourceFile.lines) {
      lineCoverageMap[line.lineNumber] = line;
    }

    // We need to read the actual source file to display the code
    // For now, we'll generate placeholder content showing coverage info
    final maxLineNumber = sourceFile.lines.isNotEmpty
        ? sourceFile.lines
              .map((l) => l.lineNumber)
              .reduce((a, b) => a > b ? a : b)
        : 0;

    for (int lineNum = 1; lineNum <= maxLineNumber; lineNum++) {
      final coverage = lineCoverageMap[lineNum];
      final cssClass = coverage != null
          ? CssGenerator.getLineCoverageClass(coverage.hitCount)
          : 'line-no-code';

      final hitCount = coverage?.hitCount ?? 0;
      final hitDisplay = coverage != null ? hitCount.toString() : '';

      buffer.writeln('        <div class="source-line $cssClass">');
      buffer.writeln('            <div class="line-number">$lineNum</div>');
      buffer.writeln('            <div class="line-hits">$hitDisplay</div>');
      buffer.writeln(
        '            <div class="line-content">// Source code line $lineNum</div>',
      );
      buffer.writeln('        </div>');
    }

    return buffer.toString();
  }

  /// Sorts source files based on options (by coverage or name)
  List<SourceFile> _sortSourceFiles(List<SourceFile> sourceFiles) {
    final files = List<SourceFile>.from(sourceFiles);

    // Sort by coverage percentage (lowest first) then by name
    files.sort((a, b) {
      final coverageComparison = a.overallCoveragePercentage.compareTo(
        b.overallCoveragePercentage,
      );
      if (coverageComparison != 0) {
        return coverageComparison;
      }
      return a.path.compareTo(b.path);
    });

    return files;
  }

  /// Gets the HTML filename for a source file
  String _getSourceFileHtmlName(String sourcePath) {
    return '${sourcePath.replaceAll('/', '_').replaceAll('\\', '_')}.html';
  }

  /// Formats timestamp for display
  String _formatTimestamp(DateTime timestamp) {
    return timestamp.toIso8601String().replaceAll('T', ' ').substring(0, 19);
  }

  /// Escapes HTML special characters
  String _escapeHtml(String text) {
    return text
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#x27;');
  }
}

/// Configuration options for HTML generation
class HtmlGeneratorOptions {
  /// Output directory for generated HTML files
  final String outputDirectory;

  /// Title for the coverage report
  final String title;

  /// Whether to show branch coverage
  final bool showBranches;

  /// Whether to show function coverage
  final bool showFunctions;

  /// Creates new HTML generator options
  const HtmlGeneratorOptions({
    required this.outputDirectory,
    this.title = 'LCOV - Code Coverage Report',
    this.showBranches = true,
    this.showFunctions = true,
  });
}
